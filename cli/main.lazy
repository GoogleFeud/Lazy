
import { thing as thing2, thing2 as thing3, thing4 } from "hello" as thing; 
import * from "ree"
import * from "aaaa" as thing444;

struct Error<T: { to_string: () -> str }, A> {
    content: T
    type: i32
    format: fn() -> str {
        `Error ${self.err_type}: ${self.content}`;
    }
    new: fn() new Error {}

}

struct CustomErrorContent {
    vars: Vec<str>!
    to_string: fn() -> str::A {
        vars.join(", ");
    }
}

enum Something {
    A,
    B,
    const,
    let,
    type
}

main {
    3..=5;
    ..5;
    ...5;
    const my_custom_error_content =  new CustomErrorContent { vars: Vec::from("Hello", " ", "World!") };
    const error = new Error<CustomErrorContent> { content: my_custom_error_content, type: 1 };
    print(error.type, A::type); // "Error 1: Hello World"

    match self {
        Test::A(var) => print(var),
        Test::C(variable) => variable + 1
    }

    if let char_token = TokenTypes::Char('c') char_token + 1;
}